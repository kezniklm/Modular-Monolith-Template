using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace SharedKernel.Generators;

[Generator]
public sealed class ResultCombineGenerator : IIncrementalGenerator
{
    private const int MinParameters = 2;

    private const int MaxParameters = 16;

    private const int EstimatedCapacity = 16384;

    private static readonly ImmutableArray<int[]> CachedIndices = Enumerable
        .Range(MinParameters, MaxParameters - MinParameters + 1)
        .Select(count => Enumerable.Range(1, count).ToArray())
        .ToImmutableArray();

    public void Initialize(IncrementalGeneratorInitializationContext context) =>
        context.RegisterPostInitializationOutput(static ctx =>
            ctx.AddSource("ResultExtensions.g.cs", SourceText.From(GenerateSource(), Encoding.UTF8)));

    private static string GenerateSource()
    {
        var sb = new StringBuilder(EstimatedCapacity);

        sb.Append(
            """
            // <auto-generated/>
            #nullable enable

            using FluentResults;

            namespace SharedKernel;

            public static class ResultExtensions
            {

            """);

        foreach (var indices in CachedIndices)
        {
            AppendCombineMethod(sb, indices);
        }

        sb.Append('}');

        return sb.ToString();
    }

    private static void AppendCombineMethod(StringBuilder sb, int[] indices)
    {
        var count = indices.Length;

        // Generate type parameters: T1, T2, T3, ...
        var typeParams = string.Join(", ", indices.Select(static n => $"T{n}"));

        // Generate tuple type: (T1, T2, T3, ...)
        var tupleType = $"({typeParams})";

        // Generate Result.Merge arguments: r1, r2, r3, ...
        var mergeArgs = string.Join(", ", indices.Select(static n => $"r{n}"));

        // Generate tuple value accessors: r1.Value, r2.Value, r3.Value, ...
        var tupleValues = string.Join(", ", indices.Select(static n => $"r{n}.Value"));

        // Generate method parameters: this Result<T1> r1, Result<T2> r2, ...
        var methodParams = string.Join(",\n        ",
            indices.Select(static n => $"{(n == 1 ? "this " : "")}Result<T{n}> r{n}"));

        sb.Append(
            $$"""
                  /// <summary>
                  /// Combines {{count}} <see cref="Result{T}"/> instances into a single result containing a tuple of all values.
                  /// </summary>
                  /// <returns>
                  /// A successful result with a tuple of all values if all inputs succeeded;
                  /// otherwise, a failed result with all errors combined.
                  /// </returns>
                  [System.Diagnostics.CodeAnalysis.SuppressMessage("Design", "CA1002:Do not expose generic lists", Justification = "Generated extension method")]
                  public static Result<{{tupleType}}> Combine<{{typeParams}}>(
                      {{methodParams}}) =>
                      Result.Merge({{mergeArgs}}) is { IsFailed: true, Errors: var errors }
                          ? Result.Fail<{{tupleType}}>(errors)
                          : Result.Ok(({{tupleValues}}));


              """);
    }
}
